//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ISpySoft.SFSchemaLanguage.Designer
{
	#region Using directives
	using System;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using Microsoft.VisualStudio;
	using Microsoft.VisualStudio.Shell.Interop;
	using Microsoft.VisualStudio.OLE.Interop;
	using Microsoft.VisualStudio.Shell;
	using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
	using Microsoft.VisualStudio.EnterpriseTools.Shell;
	using Microsoft.VisualStudio.Modeling;
	using System.Collections.Generic;
	using ISpySoft.SFSchemaLanguage.Designer.Diagram; // For resource class
	using System.ComponentModel;

	#endregion

    /// <summary>
    /// Factory for creating our editors
    /// </summary>
    [CLSCompliant(false)]
    [Guid(GuidList.guidEditorFactoryString)]
	public class EditorFactory : ModelingEditorFactory
	{
		#region Constants
	
		protected const int SchemaModelItemHasSchemaModelItemConnectorPosition = 5;
		public const string SchemaModelItemHasSchemaModelItemConnectorFilterString = "SchemaModelItemHasSchemaModelItemConnectorFilterString";
		#endregion

		public EditorFactory(SFSchemaLanguagePackage package) : base(package)
		{
		}

		protected override string MapLogicalView(Guid logicalView, object viewContext)
		{
			// We only support a single logical view, so must return an empty string.
			return "";
		}

		protected override DocData CreateDocData(string fileName, IVsHierarchy hierarchy, uint itemId)
		{
			// We have to call this to force VSHost to be initialized.
			// Only if UAM-based load/save - VSHost.GetVSHost(ServiceProvider);

			return new SFSchemaLanguageDocData(this.ServiceProvider, this);
		}

		protected override DocView CreateDocView(DocData docData, string physicalView, out string editorCaption)
		{
			editorCaption = "";
			return new SFSchemaLanguageDocView(docData, this.ServiceProvider);
		}

		#region Connector toolbox items
		/// <summary>
		/// Retrieves the ToolboxItem used by this Modeling based editor.
		/// This is where you add complex toolbox items that are not simply
		/// fragments of diagram to be added.
		/// </summary>
		public override ModelingToolboxItem[] GetToolboxItems()
		{
			// Put all the base items in the list and then add the connector tools
			List<ModelingToolboxItem> items = new List<ModelingToolboxItem>();

			// Get the base list of toolbox items
			ModelingToolboxItem[] baseItems = base.GetToolboxItems();
			foreach ( ModelingToolboxItem baseItem in baseItems)
			{
				items.Add( baseItem);
			}


	
			// Create an entry for the SchemaModelItemHasSchemaModelItemConnector tool
			{
				ModelingToolboxItem item = new ModelingToolboxItem(
					"SchemaModelItemHasSchemaModelItemConnectorToolBoxItemId", // Id
					EditorFactory.SchemaModelItemHasSchemaModelItemConnectorPosition, // Position
					EditorFactory.GetResource("ActivityHasArtifactConnectorToolboxCaption", true) as string, // Caption
					EditorFactory.GetResource("connector") as System.Drawing.Bitmap, // Bitmap
					Designer_Resource.ToolboxTab + "Id",
					Designer_Resource.ToolboxTab,
					"ExampleConnectorHelpId", // f1Keyword
					null, // Tooltip
					null, // ElementGroupPrototype
					new ToolboxItemFilterAttribute[] { new ToolboxItemFilterAttribute(SFSchemaLanguageDiagram.DiagramFilterString, ToolboxItemFilterType.Require), new ToolboxItemFilterAttribute(EditorFactory.SchemaModelItemHasSchemaModelItemConnectorFilterString, ToolboxItemFilterType.Allow) });

				items.Add(item);
			}

			// Return the augmented list
			return items.ToArray();
		}
		#endregion
		
		
		/// <summary>
		/// This interim code allows the language author to put a resource either in the 
		/// Properties\Resources or in Diagram\Resources, or directly in the DD file. All but the first are deprecated
		/// </summary>
		/// <param name="resourceName"></param>
		/// <returns></returns>
		internal static object GetResource(string resourceName)
		{
			return GetResource(resourceName, false);
		}

		
		/// <summary>
		/// This interim code allows the language author to put a resource either in the 
		/// Properties\Resources or in Diagram\Resources. The former is deprecated.
		/// </summary>
		/// <param name="resourceName"></param>
		/// <param name="nameIfMissing">Return the resource name if no resource is found.</param>
		/// <returns></returns>
		internal static object GetResource(string resourceName, bool nameIfMissing)
		{
			object value = null;
			System.Reflection.BindingFlags flags = System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static;
			System.Reflection.PropertyInfo diagramResourcesInfo = typeof(Designer_Resource).GetProperty(resourceName, flags);
			if (diagramResourcesInfo != null)
			{
				value = diagramResourcesInfo.GetValue(null, null);
			}
			else
			{
				System.Reflection.PropertyInfo designerResourcesInfo = typeof(Properties.Resources).GetProperty(resourceName, flags);
				if (designerResourcesInfo != null)
					value = designerResourcesInfo.GetValue(null, null);
			}
			if (value == null)
			{
				if (nameIfMissing) return resourceName;
				else
			                Debug.Assert(value != null, String.Format(CultureInfo.CurrentCulture, @"Missing resource {0} expected in Designer\Diagram\Designer.Resource.resx", resourceName));
			}
			return value;
		}
	}
}

