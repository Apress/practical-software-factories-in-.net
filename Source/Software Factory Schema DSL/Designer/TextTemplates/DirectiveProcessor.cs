//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ISpySoft.SFSchemaLanguage.Designer
{
	#region Using directives
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Text;
	using System.Reflection;
	using System.Reflection.Emit;
	using System.Runtime.InteropServices;
	using System.CodeDom.Compiler;
	using System.Security;
	using System.Security.Permissions;
	using System.IO;
	using System.Globalization;
	using System.Runtime.Remoting;
	using System.Diagnostics;
	using ISpySoft.SFSchemaLanguage.DomainModel ;
	using Microsoft.VisualStudio.Modeling;
	using Microsoft.VisualStudio.Modeling.Diagnostics;
	using Microsoft.VisualStudio.Shell;
	using Microsoft.VisualStudio.Modeling.Utilities;
	using Microsoft.VisualStudio.EnterpriseTools.Shell;
	using Microsoft.VisualStudio.TextTemplating;
	using Microsoft.VisualStudio.TextTemplating.VSHost;
	using System.CodeDom;
	#endregion

	/// <summary>
	/// Template directive processor that provides SFSchemaLanguage files
	/// </summary>
	public sealed class SFSchemaLanguageDirectiveProcessor : RequiresProvidesDirectiveProcessor
	{
		/// <summary>
		/// The friendly name of this processor.
		/// </summary>
		public const string SFSchemaLanguageDirectiveProcessorName = "SFSchemaLanguageDirectiveProcessor";

		/// <summary>
		/// Constructor
		/// </summary>
		public SFSchemaLanguageDirectiveProcessor()
			: base()
		{
		}

		/// <summary>
		/// The friendly name of this processor.
		/// </summary>
		protected override string FriendlyName
		{
			get
			{
				return SFSchemaLanguageDirectiveProcessorName;
			}
		}

		/// <summary>
		/// Check if the directive name is supported by this directive processor
		/// </summary>
		/// <param name="directiveName"></param>
		/// <returns></returns>
		public override bool IsDirectiveSupported(string directiveName)
		{
			return (StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0);
		}

		protected override void InitializeRequiresDictionary(string directiveName, IDictionary<string, string> requiresDictionary)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				requiresDictionary["fileName"] = null;
			}
		}

		protected override void InitializeProvidesDictionary(string directiveName, IDictionary<string, string> providesDictionary)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				providesDictionary["SchemaModel"] = "SchemaModel";
			}
		}

		/// <summary>
		/// Generate the code to access the model. Use to CodeDomProvider so we are language-agnostic
		/// </summary>
		/// <param name="directiveName"></param>
		/// <param name="codeBuffer"></param>
		/// <param name="languageProvider"></param>
		/// <param name="requiresArguments"></param>
		/// <param name="providesArguments"></param>
		protected override void GenerateTransformCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary<string, string> requiresArguments, IDictionary<string, string> providesArguments)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				if (languageProvider != null)
				{
					// Create a field to store the model once it is loaded
					CodeMemberField schemamodel = new CodeMemberField();
					schemamodel.Name = providesArguments["SchemaModel"].ToLower(CultureInfo.InvariantCulture) + "Value";
					schemamodel.Type = new CodeTypeReference(typeof(ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel));
					schemamodel.Attributes = MemberAttributes.Private;

					// Create a property for the Model that delay-loads the model
					CodeMemberProperty schemamodelProperty = new CodeMemberProperty();
					schemamodelProperty.Name = providesArguments["SchemaModel"];
					schemamodelProperty.Type = new CodeTypeReference(typeof(ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel));
					schemamodelProperty.Attributes = MemberAttributes.Private;
					schemamodelProperty.HasSet = false;
					schemamodelProperty.HasGet = true;
					schemamodelProperty.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), schemamodel.Name)));

					// Generate the actual code using the CodeDomProvider
					CodeGeneratorOptions options = new CodeGeneratorOptions();
					options.BlankLinesBetweenMembers = true;
					options.IndentString = "    ";
					options.VerbatimOrder = true;
					options.BracingStyle = "C";
					using (StringWriter writer = new StringWriter(codeBuffer, CultureInfo.InvariantCulture))
					{
						languageProvider.GenerateCodeFromMember(schemamodel, writer, options);
						languageProvider.GenerateCodeFromMember(schemamodelProperty, writer, options);
					}
				}
			}
		}

		/// <summary>
		/// Contribute additively to initialization code for the TextTransformation generated class.
		/// </summary>
		/// <remarks>
		/// This code will be added before the call to the base class.
		/// </remarks>
		/// <param name="codeBuffer"></param>
		/// <param name="languageProvider"></param>
		/// <param name="requiresArguments"></param>
		/// <param name="providesArguments"></param>
		protected override void GeneratePreInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary<string, string> requiresArguments, IDictionary<string, string> providesArguments)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				if (languageProvider != null)
				{
					string[] domainModels = {
						"Microsoft.VisualStudio.Modeling.Diagrams.CoreDesignSurface",
						"Microsoft.VisualStudio.Modeling.Utilities.UtilitiesModel",
						"ISpySoft.SFSchemaLanguage.Designer.SFSchemaLanguageDesigner",
						"ISpySoft.SFSchemaLanguage.DomainModel.SFSchemaLanguage",
					};

					CodeGeneratorOptions options = new CodeGeneratorOptions();
					options.BlankLinesBetweenMembers = true;
					options.IndentString = "    ";
					options.VerbatimOrder = true;
					options.BracingStyle = "C";
					using (StringWriter writer = new StringWriter(codeBuffer, CultureInfo.InvariantCulture))
					{
						foreach (string domainModel in domainModels)
						{
							CodeExpressionStatement addModel = new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), "AddDomainModel"), new CodeTypeOfExpression(domainModel)));
							languageProvider.GenerateCodeFromStatement(addModel, writer, options);
						}
					}
				}
			}
		}

		/// <summary>
		/// Contribute additively to initialization code for the TextTransformation generated class.
		/// </summary>
		/// <remarks>
		/// This code will be added after the call to the base class.
		/// </remarks>
		/// <param name="codeBuffer"></param>
		/// <param name="languageProvider"></param>
		/// <param name="requiresArguments"></param>
		/// <param name="providesArguments"></param>
		protected override void GeneratePostInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary<string, string> requiresArguments, IDictionary<string, string> providesArguments)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				if (languageProvider != null)
				{
					CodeMethodInvokeExpression invokeExpression = new CodeMethodInvokeExpression(
						new CodeMethodReferenceExpression(new CodeTypeReferenceExpression(typeof(ISpySoft.SFSchemaLanguage.Designer.SFSchemaLanguageFileLoader)), "Load"), new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Errors"), new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Store"), new CodePrimitiveExpression(requiresArguments["fileName"]));
					CodeAssignStatement assign = new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), providesArguments["SchemaModel"].ToLower(CultureInfo.InvariantCulture) + "Value"), invokeExpression);

					CodeGeneratorOptions options = new CodeGeneratorOptions();
					options.BlankLinesBetweenMembers = true;
					options.IndentString = "    ";
					options.VerbatimOrder = true;
					options.BracingStyle = "C";
					using (StringWriter writer = new StringWriter(codeBuffer, CultureInfo.InvariantCulture))
					{
						languageProvider.GenerateCodeFromStatement(assign, writer, options);
					}
				}
			}
		}

		protected override void PostProcessArguments(string directiveName, IDictionary<string, string> requiresArguments, IDictionary<string, string> providesArguments)
		{
			if ((StringComparer.InvariantCultureIgnoreCase.Compare(directiveName, "schemamodel") == 0))
			{
				// Give the host a chance to resolve the fileName
				requiresArguments["fileName"] = this.Host.ResolvePath(requiresArguments["fileName"]);
			}
		}

		public override string[] GetImportsForProcessingRun()
		{
			List<string> imports = new List<string>(base.GetImportsForProcessingRun());

			imports.Add("Microsoft.VisualStudio.Modeling");
			imports.Add("System.CodeDom.Compiler");
			imports.Add("ISpySoft.SFSchemaLanguage.Designer");
			imports.Add("ISpySoft.SFSchemaLanguage.DomainModel");

			return imports.ToArray();
		}

		public override string[] GetReferencesForProcessingRun()
		{
			List<string> references = new List<string>(base.GetReferencesForProcessingRun());
			
			// returning assembly strong names causes paths to these assemblies to be retrieved from the GAC.
			references.Add("Microsoft.VisualStudio.Modeling.Sdk, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
			references.Add("Microsoft.VisualStudio.Modeling.Sdk.Diagrams, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
			references.Add("Microsoft.VisualStudio.Modeling.Sdk.Utilities, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
			references.Add(this.GetType().Assembly.Location);
			references.Add(typeof(ISpySoft.SFSchemaLanguage.DomainModel.SFSchemaLanguage).Assembly.Location);
			return references.ToArray();
		}
	}


	/// <summary>
	/// Runtime helper class for the Directive processor
	/// </summary>
	public static class SFSchemaLanguageFileLoader
	{
		/// <summary>
		/// Load a SFSchemaLanguage model
		/// </summary>
		/// <param name="store"></param>
		/// <param name="inputFile"></param>
		/// <returns></returns>
		public static ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel Load(CompilerErrorCollection errors, Store store, string inputFile)
		{
			if (errors == null) throw new ArgumentNullException("errors");
			if (store == null) throw new ArgumentNullException("store");
			if (inputFile == null) throw new ArgumentNullException("inputFile");
		
			using (System.IO.FileStream fileStream = File.OpenRead(inputFile))
			{
				// Get the set before we load the file
				IList previousSet = store.ElementDirectory.GetElements(ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel.MetaClassGuid);
				try
				{
					using (Transaction t = store.TransactionManager.BeginTransaction("ProcessorLoad", true))
					{
						XmlSerialization.DeserializeStore(store, fileStream, 1, 1, SFSchemaLanguageFileLoader.UpgradeFileFormat, SFSchemaLanguageFileLoader.Deserialized);
					t.Commit();
					}
				}
				catch(Exception e)
				{
					errors.Add(new CompilerError(inputFile, -1, -1, "", e.ToString()));
				}

				IList candidates = store.ElementDirectory.GetElements(ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel.MetaClassGuid);
				// Remove the previous items from the new list, to leave just the newly added item
				foreach (ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel previous in previousSet)
				{
					if ( previous != null )
					{
						candidates.Remove(previous);
					}
				}
				
				foreach (ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel candidate in candidates)
				{
					if (candidate != null)
					{
						return candidate as ISpySoft.SFSchemaLanguage.DomainModel.SchemaModel;
					}
				}
			}
			return null;
		}

		private static void Deserialized(ModelElement modelElement)
		{
		}
		
		/// <summary>
		/// Given a file in a particular format version, upgrade the file to the current version, if possible
		/// </summary>
		/// <param name="stream">In - original stream, Out - upgraded stream</param>
		/// <param name="majorVersion">In - Major version of original stream, Out - Major version of upgraded stream</param>
		/// <param name="minorVersion">In - Minor version of original stream, Out - Minor version of upgraded stream</param>
		/// <returns>True if upgrade succeeded, false otherwise</returns>
		private static bool UpgradeFileFormat(ref System.IO.Stream stream, ref int majorVersion, ref int minorVersion)
		{
			System.Diagnostics.Debug.Fail("Nothing to upgrade yet");
			return false;
		}
	}
}

