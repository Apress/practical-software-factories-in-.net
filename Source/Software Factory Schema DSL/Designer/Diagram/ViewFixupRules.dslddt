<#@ definition processor="DDDirectiveProcessor" requires="fileName='..\Designer.dsldd'" #>
<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Drawing.dll" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Drawing" #>
//<#@ import namespace="Microsoft.VisualStudio.EnterpriseTools.Corona.Concepts" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
	// Set up a dictionary of mappings from connectors to their connectorMaps
	Dictionary<Connector, ConnectorMap> mapMap = new Dictionary<Connector, ConnectorMap>();
	foreach ( DiagramMap diagramMap in this.Definition.Notation.DiagramMaps )
	{
		foreach ( ConnectorMap connectorMap in diagramMap.ConnectorMaps )
		{
			mapMap[connectorMap.Connector]=connectorMap;
		}
	}

	// Set up dictionaries mapping relationship names for every relationship 
	// in the object model to the source and target roles. The assumption is that
	// all relationships are binary
	Dictionary<string, CdlRole> relationshipSourceRole = new Dictionary<string, CdlRole>();
	Dictionary<string, CdlRole> relationshipTargetRole = new Dictionary<string, CdlRole>();
	foreach (ObjectModel objectModel in this.Definition.ObjectModels)
	{
#>
<#
		foreach (CdlRelationship relationship in objectModel.Model.Relationships)
		{
#>
<#
			relationshipTargetRole[relationship.Name] = relationship.CdlRoles[0];
			relationshipSourceRole[relationship.Name] = relationship.CdlRoles[1];
		}
	}

	// Set up a list of strings for names of rule types. Each rule that we generate, we
	// add the name of the type to this list
	List<string> ruleTypes = new List<string>();
#>	

namespace <#=this.Definition.Namespace#>
{
	#region Using directives

	using System;
	using System.Collections.Generic;
	using System.Text;
<#	        
		// add using statements
		foreach (ObjectModel objectModel in this.Definition.ObjectModels)
		{
		    //Microsoft.VisualStudio.Modeling is automatically appended to the list explicit in the dd file
#>
	using <#= objectModel.Model.Namespace #> ;
<#
		}
#>
	using Microsoft.VisualStudio.Modeling;
	using Microsoft.VisualStudio.Modeling.Utilities;
	using Microsoft.VisualStudio.Modeling.Diagrams;
	using System.Collections;

	#endregion

	#region Structural Rules
	<#
	
		// Hashtable to store the full name of all the classes that need Decorator updates when their attributes change
    	Dictionary<string, string> targetDecoratorMaps = new Dictionary<string, string>();
		// A dictionary mapping the name of a Model Element to a list of names of relationships that are displayed using compartments 
		Dictionary<string, IList> compartmentMapNames = new Dictionary<string, IList>();

			foreach (DiagramMap diagramMap in this.Definition.Notation.DiagramMaps)
			{
				// List of target role names defined in shape maps
				Dictionary<string, string> targetSourceMap = new Dictionary<string, string>();
				// Dictionary mapping the target role name to the name of the relationship that it
				// is a role of
				Dictionary<string, string> relationshipNames = new Dictionary<string, string>();
				
				CdlConcept sourceClass = diagramMap.Class;
				string sourceClassName = sourceClass.Name;
				foreach (ShapeMap shapeMap in diagramMap.ShapeMaps)
				{
					// A list of relationships that are shown using compartments
					List<string> compRelationNames = new List<string>();

					Microsoft.VisualStudio.Modeling.DesignerDefinition.RoleExpression roleExpression = shapeMap.MelCollectionExpression as Microsoft.VisualStudio.Modeling.DesignerDefinition.RoleExpression;
					if (roleExpression != null)
					{
						targetSourceMap[roleExpression.Role.Name] = sourceClassName;
						relationshipNames[roleExpression.Role.Name] = roleExpression.Role.Relationship.Name;
					}
					foreach (ShapeTextMap textMap in shapeMap.TextMaps)
					{
						Microsoft.VisualStudio.Modeling.DesignerDefinition.ValuePropertyExpression valuePropertyExpression = textMap.ValueExpression as Microsoft.VisualStudio.Modeling.DesignerDefinition.ValuePropertyExpression;
						if (valuePropertyExpression != null)
						{
							targetDecoratorMaps[shapeMap.Class.FullyQualifiedName] = "";
						}
					}
					// Enable tracking icon visibility changes.
					foreach (ShapeIconMap iconMap in shapeMap.IconMaps)
					{
						Microsoft.VisualStudio.Modeling.DesignerDefinition.BooleanExpression valuePropertyExpression = 
							iconMap.VisibilityExpression as Microsoft.VisualStudio.Modeling.DesignerDefinition.BooleanExpression;
						if (valuePropertyExpression != null)
						{
							targetDecoratorMaps[shapeMap.Class.FullyQualifiedName] = "";
						}
					}
					foreach (CompartmentMap compMap in shapeMap.CompartmentMaps)
					{
						Microsoft.VisualStudio.Modeling.DesignerDefinition.RoleExpression compRoleExpression = compMap.MelCollectionExpression as Microsoft.VisualStudio.Modeling.DesignerDefinition.RoleExpression;
						if (compRoleExpression != null)
						{
							compRelationNames.Add(compRoleExpression.Role.Relationship.Name);
						}
					}
					
					if (compRelationNames.Count > 0)
					{
						string sourceShapeName = shapeMap.Class.Name; 
						compartmentMapNames[sourceShapeName] = compRelationNames;  
					}
				}
				foreach (ConnectorMap connectorMap in diagramMap.ConnectorMaps)
				{
					foreach (ConnectorTextMap textMap in connectorMap.TextMaps)
					{
						Microsoft.VisualStudio.Modeling.DesignerDefinition.ValuePropertyExpression valuePropertyExpression = textMap.ValueExpression as Microsoft.VisualStudio.Modeling.DesignerDefinition.ValuePropertyExpression;
						if (valuePropertyExpression != null)
						{
							targetDecoratorMaps[connectorMap.Class.FullyQualifiedName] = "";
						}
					}
				}
				foreach (string targetRoleName in targetSourceMap.Keys)
				{
					string relationName = relationshipNames[targetRoleName];
					string sourceRoleName = relationshipSourceRole[relationName].Name;
					ruleTypes.Add(relationName+"AddRule");
		// Generate rule to call FixUpDiagram whenever a relationship is added to the diagram. We do this for every relationship in the 
		// shape maps
	#>
	[RuleOn(typeof(<#=relationName#>), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	public sealed class <#=relationName#>AddRule : AddRule
	{
		/// <summary>
		/// Called when a <#=relationName#> association is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			<#=relationName#> s = e.ModelElement as <#=relationName#>;

			if (s.<#=targetRoleName#> != null && s.<#=sourceRoleName#> != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(s.<#=sourceRoleName#>, s.<#=targetRoleName#>);
			}
		}
	}
		
	<#
				}
			}
		
	#>
	
	#endregion

	#region Data change rules
	// Generated from the <diagramMap> - one RuleOn attribute entry per [text]MapProperty
	// Code generator knows that a <textMapProperty> uses the SimpleDecoratorMapping type.
	// So one rule class per mapping type, one attribute per mapping element that uses that type.
<#
	// Generate rule to handle when a decorator needs to be updated. We do this for all text decorators.
		ruleTypes.Add("DomainModelSimpleDecoratorMappingChangesRule"); 
		foreach (string targetModelClass in targetDecoratorMaps.Keys)
		{

#>
	[RuleOn(typeof(<#=targetModelClass#>), FireTime = TimeToFire.TopLevelCommit)]
<#
	}
#>
	public sealed class DomainModelSimpleDecoratorMappingChangesRule : ChangeRule
	{
  		public override void ElementAttributeChanged(ElementAttributeChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			SimpleDecoratorMapping.UpdateDecoratorsFromObjectModel(e.ModelElement, e.MetaAttribute.Id);
			
			//if (e.MetaAttribute.Id == ISpySoft.SFSchemaLanguage.DomainModel.Artifact.TypeMetaAttributeGuid)
            //{

            //    foreach (ISpySoft.SFSchemaLanguage.Designer.ArtifactShape afs in e.ModelElement.AssociatedPresentationElements)
            //    {
            //        foreach (System.ComponentModel.PropertyDescriptor property in e.ModelElement.GetProperties())
            //        {
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.Asset)
            //            {
            //                afs.FillColor = System.Drawing.Color.Lime;
            //            }
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.Tool)
            //            {
            //                afs.FillColor = System.Drawing.Color.Red;
            //            }
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.WorkProduct)
            //            {
            //                afs.FillColor = System.Drawing.Color.Green;
            //            }
            //            
            //        }

            //    }
            //}
			
		}
	}
<#
		if (compartmentMapNames.Keys.Count > 0)
		{
			foreach (string className in compartmentMapNames.Keys)
			{
				ruleTypes.Add(className + "HasListItemRemovedRule"); 
#>	
	/// <summary>
	/// Updates a compartment when an item has been removed from its list.
	/// </summary>
<#
	// Generate Rule to handle items being removed from a compartment. I.e, when 
	// a relationship being shown as a compartment is removed. We generate a RuleOn attribute for all
	// relationships on the class that are shown in a compartment. 
				foreach (string typeName in compartmentMapNames[className])
				{
#>	[RuleOn(typeof(<#=typeName#>))] 
<#
				}
#>
	public sealed class <#=className#>HasListItemRemovedRule : RemoveRule
	{
		public override void ElementRemoved(Microsoft.VisualStudio.Modeling.ElementRemovedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			CompartmentRuleHelper.HandleCompartmentUpdate(e.ModelElement as ElementLink, typeof(<#=className#>));
		}
	}
<#
				ruleTypes.Add(className + "HasListItemAddedRule"); 
#>	
	/// <summary>
	/// Updates a compartment when an item has been add to its list.
	/// </summary>
<#
	// Generate Rule to handle items being added to a compartment. I.e, when 
	// a relationship being shown as a compartment is added. We generate a RuleOn attribute for all
	// relationships on the class that are shown in a compartment. 
				foreach (string typeName in compartmentMapNames[className])
				{
#>	[RuleOn(typeof(<#=typeName#>))] 
<#
				}
#>
	public sealed class <#=className#>HasListItemAddedRule : AddRule
	{
		public override void ElementAdded(Microsoft.VisualStudio.Modeling.ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			CompartmentRuleHelper.HandleCompartmentUpdate(e.ModelElement as ElementLink, typeof(<#=className#>));
		}
	}
<#
			ruleTypes.Add(className + "HasListItemChangedRule"); 
#>	
	/// <summary>
	/// Updates both compartments when an item moved from one list to another.
	/// </summary>
<#
	// Generate Rule to handle items in a compartment changing their parent. I.e, when a roleplayerchange
	// occurs on a relationship being shown as a compartment. We generate a RuleOn attribute for all
	// relationships on the class that are shown in a compartment. 
				foreach (string typeName in compartmentMapNames[className])
				{
#>	[RuleOn(typeof(<#=typeName#>))] 
<#
				}
#>
	public sealed class <#=className#>HasListItemChangedRule : RolePlayerChangeRule
	{
		public override void RolePlayerChanged(RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			// we only need to update is the role player changed in the "parent" in the 
			// embedding relationship.
			<#=className#> oldValue = e.OldRolePlayer as <#=className#>;
			<#=className#> newValue = e.NewRolePlayer as <#=className#>;
			CompartmentRuleHelper.HandleRolePlayerChangedRule(e.ElementLink,
					oldValue, newValue);
		}
	}
<#
			}
		}
#>
	#endregion

	#region Connector Rules
	
<# 
	// Create a dictionary mapping connector names to connectors
    Dictionary <string, Connector> connectors = new Dictionary<string,Connector>();
    foreach ( Diagram diagram in this.Definition.Notation.Diagrams )
    {
        foreach (Connector connector in diagram.Connectors)
        {
            connectors[connector.Name]= connector;
        }
    }
   
	// Create a dictionary mapping connector names to the relationship that the connector 
	// represents (if there is a connector map defined for the connector) 
    Dictionary <string, CdlReferenceType> connectorClassMap = new Dictionary<string,CdlReferenceType>();
	// Create a dictionary of diagram names to the Model that the diagram represents 
    Dictionary <string, CdlReferenceType> diagramClassMap = new Dictionary<string,CdlReferenceType>();
	// Populate the two dictionaries above
    foreach (DiagramMap diagramMap in this.Definition.Notation.DiagramMaps)
    {
        diagramClassMap[diagramMap.Diagram.Name]= diagramMap.Class;
        foreach (ConnectorMap connectorMap in diagramMap.ConnectorMaps)
        { 
            if (connectorMap.Class != null && connectorMap.Connector != null)
            {
                connectorClassMap[connectorMap.Connector.Name]= connectorMap.Class;
            }
        }
    }
   
	// Create rules to add a connector when its underlying relationship is created.
	// We do this for every connector that has a connectorMap defined. 
    foreach ( Diagram diagram in this.Definition.Notation.Diagrams )
    {
		string rootElementName = diagramClassMap[diagram.Name].Name;
        foreach (Connector connector in diagram.Connectors)
        {
		if(connectorClassMap.ContainsKey(connector.Name)) 
		{
			string modelElementName = connectorClassMap[connector.Name].Name;
			ruleTypes.Add(modelElementName+"AddRule");
#>	
	
	/// <summary>
	/// Add a <#=connector.Name#> connector when its underlying relationship is created
	/// </summary>
	[RuleOn(typeof(<#=modelElementName#>), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	internal sealed class <#=modelElementName#>AddRule : AddRule
	{
		/// <summary>
		/// Called when a <#=modelElementName#> relationship is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			<#=modelElementName#> relationship = e.ModelElement as <#=modelElementName#>;
			if (relationship != null)
			{
				// M1: Get the diagram's (single) root class
				// M3: Expand to support arbirary roots with the help of the containment tree
				IList roots = relationship.Store.ElementDirectory.GetElements(<#=rootElementName#>.MetaClassGuid);
				if (roots.Count == 1)
				{
					<#=rootElementName#> root = roots[0] as <#=rootElementName#>;
					if (root != null)
					{
						Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(root, relationship);
					}
				}
			}
		}
	}
<#
			}
		}
	}
#>
<#
	// Generate a rule to reroute a connector when the role players of its underlying
	// relationship change. We do this for all connectors that have connector maps by
	// making the rule fire on the relationship represented by those connectors.
	if(connectorClassMap.Count > 0)
	{
		ruleTypes.Add("DomainModelRolePlayerConnectorChangeRule");

		foreach ( Diagram diagram in this.Definition.Notation.Diagrams )
		{
			foreach (Connector connector in diagram.Connectors)
			{
				// Check if the connector has a connector map
				if(connectorClassMap.ContainsKey(connector.Name))
				{
					string modelElementName = connectorClassMap[connector.Name].Name;
#>
	[RuleOn(typeof(<#=modelElementName#>), FireTime = TimeToFire.TopLevelCommit)]
<#
				}
			}
		}
#>
	/// <summary>
	/// Reroute a connector when the role players of its underlying relationship change
	/// </summary>
	public sealed class DomainModelRolePlayerConnectorChangeRule : RolePlayerChangeRule
	{
		public override void RolePlayerChanged(RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			if (e.NewRolePlayer != null)
			{
				foreach (PresentationElement pe in e.ElementLink.PresentationRolePlayers)
				{
					// Fix up any binary link shapes attached to the element link.
					BinaryLinkShape linkShape = pe as BinaryLinkShape;
					if (linkShape != null)
					{
						if (linkShape.ToShape != null && linkShape.ToShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "to" side of the link changed, point at new role player
							PresentationElementMoveableCollection newToShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.ToShape = newToShapes.Count > 0 ? newToShapes[0] as NodeShape : null;
						}
						else if (linkShape.FromShape != null && linkShape.FromShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "from" side of the link changed, point at new role player
							PresentationElementMoveableCollection newFromShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.FromShape = newFromShapes.Count > 0 ? newFromShapes[0] as NodeShape : null;
						}
					}
				}
			}
		}
	}
<#
	} // if(connectorClassMap.Count > 0)
#>
<#
	ruleTypes.Add("ParentShapeContainsNestedChildShapesAddRule"); 
#>
	///<summary>
	/// Rule to fixup the diagram everytime a connector is added to it
	///</summary>
	[RuleOn(typeof(ParentShapeContainsNestedChildShapes), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddConnectionRulePriority)]
	internal sealed class ParentShapeContainsNestedChildShapesAddRule : AddRule
	{
		/// <summary>
		/// Called whenever a shape is added to the diagram.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			ParentShapeContainsNestedChildShapes relationship = e.ModelElement as ParentShapeContainsNestedChildShapes;

			bool fixup = false;
<#
	foreach ( Diagram diagram in this.Definition.Notation.Diagrams )
	{
#>
			if (relationship.ParentShape is <#=diagram.Name#>)
			{
<#
		foreach ( Connector connector in diagram.Connectors )
		{
#>
				if (relationship.NestedChildShapes is <#=connector.Name#>)
				{
					fixup = true;
				}
<#
		}
#>
			}
<#
	}
#>
			if ( fixup && relationship.ParentShape.ModelElement != null && relationship.NestedChildShapes.ModelElement != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(relationship.ParentShape.ModelElement, relationship.NestedChildShapes.ModelElement);
			}
		}
	}

	#endregion
	
	/// <summary>
	/// A class that contains the types of generated rules as static variables.
	/// This class will be reflected on to get the rule types for loading
	/// the metamodel
	/// </summary>
	internal static partial class GeneratedMetaModelTypes
	{
<#
	foreach(string ruleType in ruleTypes) 
	{
#>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type <#=ruleType#>Type = typeof(<#=ruleType#>);
<#
	}
#>
	}
}