////------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

	

namespace ISpySoft.SFSchemaLanguage.Designer
{
	#region Using directives

	using System;
	using System.Collections.Generic;
	using System.Text;
	using ISpySoft.SFSchemaLanguage.DomainModel ;
	using Microsoft.VisualStudio.Modeling;
	using Microsoft.VisualStudio.Modeling.Utilities;
	using Microsoft.VisualStudio.Modeling.Diagrams;
	using System.Collections;

	#endregion

	#region Structural Rules
		[RuleOn(typeof(SchemaModelHasSchemaModelItem), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	public sealed class SchemaModelHasSchemaModelItemAddRule : AddRule
	{
		/// <summary>
		/// Called when a SchemaModelHasSchemaModelItem association is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			SchemaModelHasSchemaModelItem s = e.ModelElement as SchemaModelHasSchemaModelItem;

			if (s.SchemaModelItems != null && s.SchemaModel != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(s.SchemaModel, s.SchemaModelItems);
			}
		}
	}
		
		
	#endregion

	#region Data change rules
	// Generated from the <diagramMap> - one RuleOn attribute entry per [text]MapProperty
	// Code generator knows that a <textMapProperty> uses the SimpleDecoratorMapping type.
	// So one rule class per mapping type, one attribute per mapping element that uses that type.
	[RuleOn(typeof(ISpySoft.SFSchemaLanguage.DomainModel.Activity), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.SFSchemaLanguage.DomainModel.Artifact), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.SFSchemaLanguage.DomainModel.Mapping), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.SFSchemaLanguage.DomainModel.ViewPoint), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.SFSchemaLanguage.DomainModel.SchemaModelItemHasSchemaModelItem), FireTime = TimeToFire.TopLevelCommit)]
	public sealed class DomainModelSimpleDecoratorMappingChangesRule : ChangeRule
	{
  		public override void ElementAttributeChanged(ElementAttributeChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			SimpleDecoratorMapping.UpdateDecoratorsFromObjectModel(e.ModelElement, e.MetaAttribute.Id);
			
			//if (e.MetaAttribute.Id == ISpySoft.SFSchemaLanguage.DomainModel.Artifact.TypeMetaAttributeGuid)
            //{

            //    foreach (ISpySoft.SFSchemaLanguage.Designer.ArtifactShape afs in e.ModelElement.AssociatedPresentationElements)
            //    {
            //        foreach (System.ComponentModel.PropertyDescriptor property in e.ModelElement.GetProperties())
            //        {
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.Asset)
            //            {
            //                afs.FillColor = System.Drawing.Color.Lime;
            //            }
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.Tool)
            //            {
            //                afs.FillColor = System.Drawing.Color.Red;
            //            }
            //            if (property.Name == "Type" && (ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType)property.GetValue(property) == ISpySoft.SFSchemaLanguage.DomainModel.ArtifactType.WorkProduct)
            //            {
            //                afs.FillColor = System.Drawing.Color.Green;
            //            }
            //            
            //        }

            //    }
            //}
			
		}
	}
	
	/// <summary>
	/// Updates a compartment when an item has been removed from its list.
	/// </summary>
	[RuleOn(typeof(ViewPointHasStakeholder))] 
	public sealed class ViewPointHasListItemRemovedRule : RemoveRule
	{
		public override void ElementRemoved(Microsoft.VisualStudio.Modeling.ElementRemovedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			CompartmentRuleHelper.HandleCompartmentUpdate(e.ModelElement as ElementLink, typeof(ViewPoint));
		}
	}
	
	/// <summary>
	/// Updates a compartment when an item has been add to its list.
	/// </summary>
	[RuleOn(typeof(ViewPointHasStakeholder))] 
	public sealed class ViewPointHasListItemAddedRule : AddRule
	{
		public override void ElementAdded(Microsoft.VisualStudio.Modeling.ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			CompartmentRuleHelper.HandleCompartmentUpdate(e.ModelElement as ElementLink, typeof(ViewPoint));
		}
	}
	
	/// <summary>
	/// Updates both compartments when an item moved from one list to another.
	/// </summary>
	[RuleOn(typeof(ViewPointHasStakeholder))] 
	public sealed class ViewPointHasListItemChangedRule : RolePlayerChangeRule
	{
		public override void RolePlayerChanged(RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			// we only need to update is the role player changed in the "parent" in the 
			// embedding relationship.
			ViewPoint oldValue = e.OldRolePlayer as ViewPoint;
			ViewPoint newValue = e.NewRolePlayer as ViewPoint;
			CompartmentRuleHelper.HandleRolePlayerChangedRule(e.ElementLink,
					oldValue, newValue);
		}
	}
	#endregion

	#region Connector Rules
	
	
	
	/// <summary>
	/// Add a SchemaModelItemHasSchemaModelItemConnector connector when its underlying relationship is created
	/// </summary>
	[RuleOn(typeof(SchemaModelItemHasSchemaModelItem), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	internal sealed class SchemaModelItemHasSchemaModelItemAddRule : AddRule
	{
		/// <summary>
		/// Called when a SchemaModelItemHasSchemaModelItem relationship is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			SchemaModelItemHasSchemaModelItem relationship = e.ModelElement as SchemaModelItemHasSchemaModelItem;
			if (relationship != null)
			{
				// M1: Get the diagram's (single) root class
				// M3: Expand to support arbirary roots with the help of the containment tree
				IList roots = relationship.Store.ElementDirectory.GetElements(SchemaModel.MetaClassGuid);
				if (roots.Count == 1)
				{
					SchemaModel root = roots[0] as SchemaModel;
					if (root != null)
					{
						Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(root, relationship);
					}
				}
			}
		}
	}
	[RuleOn(typeof(SchemaModelItemHasSchemaModelItem), FireTime = TimeToFire.TopLevelCommit)]
	/// <summary>
	/// Reroute a connector when the role players of its underlying relationship change
	/// </summary>
	public sealed class DomainModelRolePlayerConnectorChangeRule : RolePlayerChangeRule
	{
		public override void RolePlayerChanged(RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			if (e.NewRolePlayer != null)
			{
				foreach (PresentationElement pe in e.ElementLink.PresentationRolePlayers)
				{
					// Fix up any binary link shapes attached to the element link.
					BinaryLinkShape linkShape = pe as BinaryLinkShape;
					if (linkShape != null)
					{
						if (linkShape.ToShape != null && linkShape.ToShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "to" side of the link changed, point at new role player
							PresentationElementMoveableCollection newToShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.ToShape = newToShapes.Count > 0 ? newToShapes[0] as NodeShape : null;
						}
						else if (linkShape.FromShape != null && linkShape.FromShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "from" side of the link changed, point at new role player
							PresentationElementMoveableCollection newFromShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.FromShape = newFromShapes.Count > 0 ? newFromShapes[0] as NodeShape : null;
						}
					}
				}
			}
		}
	}
	///<summary>
	/// Rule to fixup the diagram everytime a connector is added to it
	///</summary>
	[RuleOn(typeof(ParentShapeContainsNestedChildShapes), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddConnectionRulePriority)]
	internal sealed class ParentShapeContainsNestedChildShapesAddRule : AddRule
	{
		/// <summary>
		/// Called whenever a shape is added to the diagram.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			ParentShapeContainsNestedChildShapes relationship = e.ModelElement as ParentShapeContainsNestedChildShapes;

			bool fixup = false;
			if (relationship.ParentShape is SFSchemaLanguageDiagram)
			{
				if (relationship.NestedChildShapes is SchemaModelItemHasSchemaModelItemConnector)
				{
					fixup = true;
				}
			}
			if ( fixup && relationship.ParentShape.ModelElement != null && relationship.NestedChildShapes.ModelElement != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(relationship.ParentShape.ModelElement, relationship.NestedChildShapes.ModelElement);
			}
		}
	}

	#endregion
	
	/// <summary>
	/// A class that contains the types of generated rules as static variables.
	/// This class will be reflected on to get the rule types for loading
	/// the metamodel
	/// </summary>
	internal static partial class GeneratedMetaModelTypes
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type SchemaModelHasSchemaModelItemAddRuleType = typeof(SchemaModelHasSchemaModelItemAddRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type DomainModelSimpleDecoratorMappingChangesRuleType = typeof(DomainModelSimpleDecoratorMappingChangesRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ViewPointHasListItemRemovedRuleType = typeof(ViewPointHasListItemRemovedRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ViewPointHasListItemAddedRuleType = typeof(ViewPointHasListItemAddedRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ViewPointHasListItemChangedRuleType = typeof(ViewPointHasListItemChangedRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type SchemaModelItemHasSchemaModelItemAddRuleType = typeof(SchemaModelItemHasSchemaModelItemAddRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type DomainModelRolePlayerConnectorChangeRuleType = typeof(DomainModelRolePlayerConnectorChangeRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ParentShapeContainsNestedChildShapesAddRuleType = typeof(ParentShapeContainsNestedChildShapesAddRule);
	}
}