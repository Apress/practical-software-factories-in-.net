//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

	

namespace ISpySoft.FeatureModelLanguage.Designer
{
	#region Using directives

	using System;
	using System.Collections.Generic;
	using System.Text;
	using ISpySoft.FeatureModelLanguage.DomainModel ;
	using Microsoft.VisualStudio.Modeling;
	using Microsoft.VisualStudio.Modeling.Utilities;
	using Microsoft.VisualStudio.Modeling.Diagrams;
	using System.Collections;

	#endregion

	#region Structural Rules
		[RuleOn(typeof(ActivityGraphHasElements), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	public sealed class ActivityGraphHasElementsAddRule : AddRule
	{
		/// <summary>
		/// Called when a ActivityGraphHasElements association is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			ActivityGraphHasElements s = e.ModelElement as ActivityGraphHasElements;

			if (s.Elements != null && s.FeatureModel != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(s.FeatureModel, s.Elements);
			}
		}
	}
		
		
	#endregion

	#region Data change rules
	// Generated from the <diagramMap> - one RuleOn attribute entry per [text]MapProperty
	// Code generator knows that a <textMapProperty> uses the SimpleDecoratorMapping type.
	// So one rule class per mapping type, one attribute per mapping element that uses that type.
	[RuleOn(typeof(ISpySoft.FeatureModelLanguage.DomainModel.FeatureSet), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.FeatureModelLanguage.DomainModel.Feature), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(ISpySoft.FeatureModelLanguage.DomainModel.RootFeature), FireTime = TimeToFire.TopLevelCommit)]
	public sealed class DomainModelSimpleDecoratorMappingChangesRule : ChangeRule
	{
  		public override void ElementAttributeChanged(ElementAttributeChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			SimpleDecoratorMapping.UpdateDecoratorsFromObjectModel(e.ModelElement, e.MetaAttribute.Id);
		}
	}
	#endregion

	#region Connector Rules
	
	
	
	/// <summary>
	/// Add a RelationshipFeatureConnector connector when its underlying relationship is created
	/// </summary>
	[RuleOn(typeof(RelationshipFeature), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	internal sealed class RelationshipFeatureAddRule : AddRule
	{
		/// <summary>
		/// Called when a RelationshipFeature relationship is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			RelationshipFeature relationship = e.ModelElement as RelationshipFeature;
			if (relationship != null)
			{
				// M1: Get the diagram's (single) root class
				// M3: Expand to support arbirary roots with the help of the containment tree
				IList roots = relationship.Store.ElementDirectory.GetElements(FeatureModel.MetaClassGuid);
				if (roots.Count == 1)
				{
					FeatureModel root = roots[0] as FeatureModel;
					if (root != null)
					{
						Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(root, relationship);
					}
				}
			}
		}
	}
	
	
	/// <summary>
	/// Add a RelationshipFeatureSetConnector connector when its underlying relationship is created
	/// </summary>
	[RuleOn(typeof(RelationshipFeatureSet), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddShapeRulePriority)]
	internal sealed class RelationshipFeatureSetAddRule : AddRule
	{
		/// <summary>
		/// Called when a RelationshipFeatureSet relationship is created.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			RelationshipFeatureSet relationship = e.ModelElement as RelationshipFeatureSet;
			if (relationship != null)
			{
				// M1: Get the diagram's (single) root class
				// M3: Expand to support arbirary roots with the help of the containment tree
				IList roots = relationship.Store.ElementDirectory.GetElements(FeatureModel.MetaClassGuid);
				if (roots.Count == 1)
				{
					FeatureModel root = roots[0] as FeatureModel;
					if (root != null)
					{
						Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(root, relationship);
					}
				}
			}
		}
	}
	[RuleOn(typeof(RelationshipFeature), FireTime = TimeToFire.TopLevelCommit)]
	[RuleOn(typeof(RelationshipFeatureSet), FireTime = TimeToFire.TopLevelCommit)]
	/// <summary>
	/// Reroute a connector when the role players of its underlying relationship change
	/// </summary>
	public sealed class DomainModelRolePlayerConnectorChangeRule : RolePlayerChangeRule
	{
		public override void RolePlayerChanged(RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			if (e.NewRolePlayer != null)
			{
				foreach (PresentationElement pe in e.ElementLink.PresentationRolePlayers)
				{
					// Fix up any binary link shapes attached to the element link.
					BinaryLinkShape linkShape = pe as BinaryLinkShape;
					if (linkShape != null)
					{
						if (linkShape.ToShape != null && linkShape.ToShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "to" side of the link changed, point at new role player
							PresentationElementMoveableCollection newToShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.ToShape = newToShapes.Count > 0 ? newToShapes[0] as NodeShape : null;
						}
						else if (linkShape.FromShape != null && linkShape.FromShape.ModelElement == e.OldRolePlayer)
						{
							// The role player on the "from" side of the link changed, point at new role player
							PresentationElementMoveableCollection newFromShapes = e.NewRolePlayer.PresentationRolePlayers;
							linkShape.FromShape = newFromShapes.Count > 0 ? newFromShapes[0] as NodeShape : null;
						}
					}
				}
			}
		}
	}
	///<summary>
	/// Rule to fixup the diagram everytime a connector is added to it
	///</summary>
	[RuleOn(typeof(ParentShapeContainsNestedChildShapes), FireTime = TimeToFire.TopLevelCommit, Priority = DiagramFixupConstants.AddConnectionRulePriority)]
	internal sealed class ParentShapeContainsNestedChildShapesAddRule : AddRule
	{
		/// <summary>
		/// Called whenever a shape is added to the diagram.
		/// </summary>
		/// <param name="e">Argument to event</param>
		public override void ElementAdded(ElementAddedEventArgs e)
		{
			if (e == null) throw new ArgumentNullException("e");
			
			ParentShapeContainsNestedChildShapes relationship = e.ModelElement as ParentShapeContainsNestedChildShapes;

			bool fixup = false;
			if (relationship.ParentShape is FeatureModelLanguageDiagram)
			{
				if (relationship.NestedChildShapes is RelationshipFeatureConnector)
				{
					fixup = true;
				}
				if (relationship.NestedChildShapes is RelationshipFeatureSetConnector)
				{
					fixup = true;
				}
			}
			if ( fixup && relationship.ParentShape.ModelElement != null && relationship.NestedChildShapes.ModelElement != null)
			{
				Microsoft.VisualStudio.Modeling.Diagrams.Diagram.FixUpDiagram(relationship.ParentShape.ModelElement, relationship.NestedChildShapes.ModelElement);
			}
		}
	}

	#endregion
	
	/// <summary>
	/// A class that contains the types of generated rules as static variables.
	/// This class will be reflected on to get the rule types for loading
	/// the metamodel
	/// </summary>
	internal static partial class GeneratedMetaModelTypes
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ActivityGraphHasElementsAddRuleType = typeof(ActivityGraphHasElementsAddRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type DomainModelSimpleDecoratorMappingChangesRuleType = typeof(DomainModelSimpleDecoratorMappingChangesRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type RelationshipFeatureAddRuleType = typeof(RelationshipFeatureAddRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type RelationshipFeatureSetAddRuleType = typeof(RelationshipFeatureSetAddRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type DomainModelRolePlayerConnectorChangeRuleType = typeof(DomainModelRolePlayerConnectorChangeRule);
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
		internal static Type ParentShapeContainsNestedChildShapesAddRuleType = typeof(ParentShapeContainsNestedChildShapesAddRule);
	}
}

